"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[649],{1300:(e,t,i)=>{i.d(t,{r:()=>n});var o=i(2115);function n(e){let[t,i]=(0,o.useState)(!1),[n,r]=(0,o.useState)(!1);return(0,o.useEffect)(()=>{r(!0);let t=window.matchMedia(e);i(t.matches);let o=e=>i(e.matches);return t.addEventListener("change",o),()=>t.removeEventListener("change",o)},[e]),!!n&&t}},5654:(e,t,i)=>{i.d(t,{Tj:()=>f,Ln:()=>d,d9:()=>g,US:()=>w});var o=i(5155);let n=e=>{let{children:t}=e;return(0,o.jsx)("h1",{className:"text-5xl mb-5",children:t})},r=e=>{let{children:t}=e;return(0,o.jsx)("ul",{className:"pl-10 list-decimal list-outside font-light",children:t})},a=()=>(0,o.jsx)("hr",{className:"mb-5"}),s=e=>{let{children:t}=e;return(0,o.jsx)("h1",{className:"text-2xl pb-2 pt-5",children:t})},c=e=>{let{children:t}=e;return(0,o.jsx)("p",{className:"font-light",children:t})};i(6766),i(2115);var h=i(6874);let l={name:"Intermittent Computing",color:{border:{solid:"border-red-700",hover:"hover:border-red-700"},text:"hover:text-red-700"},description:"Battery-free computing",image:"/assets/project_images/IntermittentComputing/msp430launchpad.png",body:(0,o.jsx)(function(){return(0,o.jsxs)("div",{className:"py-5",children:[(0,o.jsx)(n,{children:"Intermittent Computing"}),(0,o.jsx)(a,{}),(0,o.jsx)(s,{children:"Description"}),(0,o.jsx)(c,{children:"This project was originally for the 2024 International Conference on Embedded Wireless Systems and Networks (EWSN) Call For Competitors. The goal of this competition was to implement and evaluate different approaches to designing efficient intermittently-powered sensing systems. Ideally, this would advance the field of battery-free computing and energy harvesting research."}),(0,o.jsx)(s,{children:"Objectives (from the official website)"}),(0,o.jsx)(c,{children:"The winning team will be the one maximizing the number of challenges solved over a predefined time window, during which the competition organizers will emulate varying degrees of available energy. To solve a challenge, contestants have to utilize hashcash, a SHA1-based proof-of-work algorithm for which a reference implementation is provided by the organizers."}),(0,o.jsx)("br",{}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"Example:"})," Using a challenge ‘EWSN2024‘ and a difficulty of 16-bit, we first create a starting string with a well-known format, e.g.,"," ",(0,o.jsx)("i",{children:"1:16:240403:EWSN2024::WXhnFeDleN:1"}),". The segments of the string separated by a colon are: version (always 1), bits (16 as per difficulty), date (6 digits, fixed for the competition), resource (the challenge word given), extension (empty), random (a user-chosen random string), and a counter. We now need to check if this string’s SHA1 hash has 16 (as per the chosen difficulty) leading zeros (most significant bits). Our string (with the counter of 1) has a SHA1 hash of"," ",(0,o.jsx)("i",{children:"20db26cb6b1e17a2079fc3daf05fd01a7ed08cb5"}),", which only has two leading zeros. Thus, we increment the counter to 2 and hash the updated string and keep incrementing the counter until we find a string that has a hash with the required leading zeros. In this example, after 96620 attempts, the string with counter 96620"," ",(0,o.jsx)("i",{children:"1:16:240403:EWSN2024::WXhnFeDleN:96620"})," has a hash of"," ",(0,o.jsx)("i",{children:"0000babe195c81d00ecec4cd8f0dc1572ebd46d4"})," with 16 leading zeros (0x0000) as required. The string"," ",(0,o.jsx)("i",{children:"1:16:240403:EWSN2024::WXhnFeDleN:96620"})," is hence the solution to the challenge."]}),(0,o.jsx)("br",{}),(0,o.jsx)(c,{children:"At the start of an experiment, an external I2C FRAM memory will contain a list of challenges similar to the above example, to which contestants need to supply a solution despite the intermittent energy supply. At the end of an experiment, the computed solutions are automatically collected by E-Cube, the number of correct solutions is tallied against any incorrect solutions, and points awarded accordingly. Additional technical details, a reference solution, as well as the evaluation procedure will be posted on the competition’s website."}),(0,o.jsx)(s,{children:"Introduction"}),(0,o.jsx)(c,{children:"In Embedded and Wireless Systems, using energy harvesting devices with non-trivial compute performance demands new thinking on call stack and memory management. The core complexity resides not in a lack of available power but rather in the uncertainty of whether power will remain steady in the next clock cycle. We want to practice implementing novel approaches in scenarios that may corrupt the system or compromise the validity of output data."}),(0,o.jsx)(s,{children:"Constraints"}),(0,o.jsx)(c,{children:"In this competition, we're constrained to the MSP430FR5994 MCU and subjected to power shutoff that can be observed and handled by the firmware. We addressed these challenges through a structured approach: modular functions, state-saving in non-volatile memory (NVM), and optimized compiler-level control over memory and operations."}),(0,o.jsx)(s,{children:"Hashcash"}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"TLDR"}),": Hashcash is a proof-of-work algorithm that uses a SHA-1 hashing algorithm. The goal is to find a string that, when hashed, has a certain number of leading zeros. When this string is found, the algorithm ends. Otherwise, the produced hash will be run through the SHA-1 algorithm again. This process is repeated until the desired hash is found."]}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"Long"}),": Just go to"," ",(0,o.jsx)("a",{href:"https://en.wikipedia.org/wiki/Hashcash",className:"underline text-blue-500",children:"Wikipedia"}),"."]}),(0,o.jsx)(s,{children:"Approach"}),(0,o.jsx)(c,{children:"Our approach aims to be a hybrid inspired by many works in the area. Initially approaching the problem’s literature review, we recognized several trends:"}),(0,o.jsxs)(r,{children:[(0,o.jsxs)("li",{children:[(0,o.jsx)("b",{children:"Write After Read (WAR) hazards:"})," WAR hazards are easily the primary inhibitor to intermittent computing, i.e. how can we design a system that will remain consistent through power failures? We were really inspired by"," ",(0,o.jsx)("a",{href:"https://dl.acm.org/doi/10.1145/3519939.3523454",className:"underline text-blue-500",children:"WARio"}),", the custom compiler instruction approach by ",(0,o.jsx)("i",{children:"Kortbeek, et.al."})]}),(0,o.jsxs)("li",{children:[(0,o.jsx)("b",{children:"Energy-efficient code:"})," Similar to how high-performance computing focuses on optimizing performance, our code had to be optimized to reduce energy consumption."]}),(0,o.jsxs)("li",{children:[(0,o.jsx)("b",{children:"State Saving:"})," We know ahead of time that the system is going to have a power failure by design. Therefore, the code needs to have a reliable method to continue computations without completely restarting from the top."]})]}),(0,o.jsx)(s,{children:"Handling WAR Hazards"}),(0,o.jsx)(c,{children:"Due to the importance of consistency, Write After Read (WAR) hazards are at the heart of the intermittent computing challenge. WAR hazards occur when a subsequent write operation modifies a value that has not been fully read by a prior operation, leading to inconsistent states following a power loss. To overcome these hazards, we used customized compiler instructions to minimize WAR occurrences. We restructured the code to minimize WAR operations by grouping them into atomic function blocks to ensure that a block either runs to completion or not at all. This design guarantees a consistent recovery state by preventing partially updated variables."}),(0,o.jsx)("br",{}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"Compiler Control:"})," By customizing compiler flags and reordering instructions, we ensured that memory and register operations were executed in an optimized sequence to avoid read-write conflicts and memory corruption."]}),(0,o.jsx)(s,{children:"Code Efficiency"}),(0,o.jsx)(c,{children:"Ensuring efficient reads and writes in our program involved managing the program state effectively and saving at crucial moments. Managing the state of the system across power interruptions required a robust state-saving mechanism in non-volatile memory (NVM). We implemented a checkpoint system that checks significant amounts of information at once, rather than as data is updated."}),(0,o.jsx)("br",{}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"Context Structure:"})," A custom ",(0,o.jsx)("code",{children:"context_t"})," struct was used to store key variables, such as SHA-1 state values, message, and iterations. This structure was saved to NVM in batches after each atomic function to try and keep the variables as updated as possible."]}),(0,o.jsx)("br",{}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"Checkpointing:"})," It is common practice to checkpoint, or save the current state of the program after key computations or expensive operations to avoid excessive computations and maintain important information in memory. We implemented this through function atomicity. After completing a function, all the data from that computation were stored in NVM before continuing."]}),(0,o.jsx)(s,{children:"Function Modularity and Atomic Design"}),(0,o.jsx)(c,{children:"Our system was designed with modular functions, isolating portions of the SHA-1 computation to complete before continuing to the next step in the algorithm."}),(0,o.jsx)("br",{}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"Atomic Function Execution:"})," Each function was designed to be completed before updating the context, ensuring that the system could resume from any function call without reprocessing previously completed work. We also aimed to minimize work within each function to promote frequent variable updates."]}),(0,o.jsx)("br",{}),(0,o.jsxs)(c,{children:[(0,o.jsx)("b",{children:"Instruction Pointer Flag:"})," An instruction pointer flag is used to check which function was currently running when power was shut off. On startup, the program will continue the algorithm from the last function to ensure minimal data loss and avoid unnecessary computing."]}),(0,o.jsx)(s,{children:"Results"}),(0,o.jsxs)(c,{children:["Our implementation worked (",(0,o.jsx)("i",{children:"for the most part"}),"). We were able to get a working implementation of hashcash. We also had a sample intermittent computing program running that continuously when power is cut. But we weren't able to integrate intermittent computing into the hashcash algorithm, so we didn't get a submission in to the competition."]}),(0,o.jsx)("br",{}),(0,o.jsx)(c,{children:"Overall, I'm a little sad we didn't get to actually participate but I had a decent idea that we weren't going to have a shot, especially since we're going to be competing against full time PhD students and researchers. But I'm glad for the experience and it was fun, at least getting it implemented."})]})},{})},d=[{name:"Verdra",color:{border:{solid:"border-green-700",hover:"hover:border-green-700"},text:"hover:text-green-800"},description:"Optimize your cloud computing",image:"/assets/project_images/Verdra/verdra.png",link:"https://verdratech.github.io/Verdra-Site/"},{name:"Green Electronics Workshop",color:{border:{solid:"border-green-600",hover:"hover:border-green-600"},text:"hover:text-green-700"},description:"How to make electronics sustainable",image:"/assets/project_images/SustainableElectronicsWorkshop/fern.png",body:(0,o.jsx)(function(){let e="https://github.com/marker6275/Sustainable-Electronics-Workshop";return(0,o.jsxs)("div",{className:"py-5",children:[(0,o.jsx)(n,{children:"Sustainable Electronics Workshop"}),(0,o.jsx)(a,{}),(0,o.jsx)(s,{children:"Background"}),(0,o.jsx)(c,{children:"This was my master's project at Northwestern University, where I was part of VAK Lab, led by Professor Nivedita Arora. I designed a course on sustainability in computing and electronics. I wanted to make a workshop that would teach college undergraduates about how sustainability fits in our technology. I chose to focus on the key issues of sustainability and what we, as engineers, can do to make technology more sustainable."}),(0,o.jsx)("br",{}),(0,o.jsx)(c,{children:"Initially, I wanted to make a sustainability hackathon, where we could provide students with discarded electronics and have them design something new using old parts. However, there were many problems that arose with this idea - there was too much to do in too short of a time for students, there were many prerequisites to fill, and inter-electronic compatability was difficult to handle. So this idea got scrapped pretty quick."}),(0,o.jsx)("br",{}),(0,o.jsx)(c,{children:"The second idea was less of a workshop, but focused more on sustainability with electronics. I wanted to create a work of art using discarded PCBs to recycle a usually unrecyclable material. The idea was to use PCBs as capacitance touch sensors, as to where you could tap on the PCB and a light would turn on or a note would play. I was able to achieve proof of concept for this to work, but since we wanted to focus more on education, we pivoted this idea to a traditional workshop, although I may revisit this idea in the future."}),(0,o.jsx)(s,{children:"Workshop Materials"}),(0,o.jsxs)(c,{children:[(0,o.jsx)("span",{className:"font-semibold",children:"All workshop materials are available on this Github repo:"})," ",(0,o.jsx)("a",{href:e,className:"underline text-blue-500",target:"_blank",rel:"noopener noreferrer",children:e})]}),(0,o.jsx)("br",{}),(0,o.jsxs)(c,{children:["Also in this repo is a"," ",(0,o.jsx)("a",{href:"https://github.com/marker6275/Sustainable-Electronics-Workshop/blob/main/Project_Report.pdf",className:"underline text-blue-500",target:"_blank",rel:"noopener noreferrer",children:"full project report"}),". Everything following this is a rough summary of the project."]}),(0,o.jsx)(s,{children:"Course Design"}),(0,o.jsx)(c,{children:"This workshop was meant to be an 80-minute workshop, where we would cover the key concepts of sustainability in computing. The target audience of the workshop was college undergraduates, and while we focused on students studying computer science, computer engineering, and electrical engineering, this course would be accessible to all engineers, and potentially even non-engineers. The only real prerequities are a basic understanding of circuits so students could take this at all levels of study. We never quite nailed down the specific grade levels we wanted to target since there were arguments for all. I would have liked to target younger students, such as freshmen who had recently took introductory courses so this idea of sustainability in design would be introduced early on."}),(0,o.jsx)(s,{children:"Workshop Goals"}),(0,o.jsxs)(r,{children:[(0,o.jsx)("li",{children:"Understand embodied and operational carbon in electronics"}),(0,o.jsx)("li",{children:"Learn the basics of life cycle assessment as a tool"}),(0,o.jsx)("li",{children:"Recognize how material choices and energy use affect a device's environmental footprint"}),(0,o.jsx)("li",{children:"Apply sustainable thinking to consider a product's entire life cycle"})]}),(0,o.jsx)(s,{children:"Topics Covered"}),(0,o.jsxs)(r,{children:[(0,o.jsx)("li",{children:"Embodied and operational carbon"}),(0,o.jsx)("li",{children:"Life Cycle Assessment"}),(0,o.jsx)("li",{children:"Material and Energy Analysis"})]}),(0,o.jsx)(s,{children:"Workshop Flow"}),(0,o.jsx)(c,{children:"The workshop started with a quick lecture on the main ideas of sustainability and how they relate to electronics. It covers the carbon footprint, embodied and operational carbon, and how to calculate and discover these numbers. Then, we cover the concept of a life cycle assessment and how to use it to quantify how the environmental impact of a product. Then, we jump to an activity where students created circuits to consider the tradeoffs of different materials and how they affect the carbon footprint of a product. We wrapped up with examples as to how these tradeoffs are applied in industry."}),(0,o.jsx)(s,{children:"Activity"}),(0,o.jsx)(c,{children:"The activity, which was the main highlight of the workshop, was a circuit design activity. We provided students with cardstock, carbon paint, copper tape, and a battery. Students were tasked with creating a circuit that would turn on a light using the provided materials, but focusing on producting the least amount of carbon. We had a worksheet that guided students through the process of designing the circuit and calculating the carbon footprint of the circuit."}),(0,o.jsx)(s,{children:"Results"}),(0,o.jsx)(c,{children:"We weren't able to formally run the workshop, but we did get to do a pilot with a few students. The feedback was positive, and everything seemed to make sense and run smoothly. Students were able to understand the concepts and apply them to the activity. Students were also able to create circuits according to the instructions and understand the tradeoffs of different materials. I would love to run the workshop for real some day. I think this would be a great way to introduce sustainability to engineering students, so I would love to see this truly taught in a college setting."})]})},{})},l],u=["projects","music","resume","bets","misc"],m=["tic tac toe"],p={"tic tac toe":"tic-tac-toe"};function g(e){if("home"===e)return"/";if(u.includes(e.toLowerCase()))return"/".concat(e.toLowerCase());if(m.includes(e.toLowerCase())){let t=p[e.toLowerCase()];return"/misc/".concat(t)}return null}let f=[["hover:text-[#1C49FF]","hover:bg-[#E3E8FF]","hover:border-[#1C49FF]"],["hover:text-[#1C55E0]","hover:bg-[#E3EAFB]","hover:border-[#1C55E0]"],["hover:text-[#1C61C1]","hover:bg-[#E3ECF7]","hover:border-[#1C61C1]"],["hover:text-[#1C6DA2]","hover:bg-[#E3EEF3]","hover:border-[#1C6DA2]"],["hover:text-[#1C7983]","hover:bg-[#E3F0EF]","hover:border-[#1C7983]"],["hover:text-[#1C8564]","hover:bg-[#E3F2EB]","hover:border-[#1C8564]"],["hover:text-[#1C9145]","hover:bg-[#E3F4E7]","hover:border-[#1C9145]"],["hover:text-[#1C9D26]","hover:bg-[#E3F6E3]","hover:border-[#1C9D26]"],["hover:text-[#1CA907]","hover:bg-[#E3F8DF]","hover:border-[#1CA907]"]],w=["January","February","March","April","May","June","July","August","September","October","November","December"]}}]);